#Linked List
## singly linked list

```js

// Node와 Node를 연결하는 것은 주소를 참조한다는 것
// 포인터가 next일 필요는 없음

class Node {
  constructor(data) {
    this.data = data;
    this.next = null;
  }
}

const node1 = new Node(10);
const node2 = new Node(20);

node1.next = node2;

let head = node1;

//헤드로 첫번째 노드를 가르키게 설정

function add(value) {
  const newNode = new Node(value);
  // 새로운 노드 생성. 현재 떠다니고 있는 상태
  let currentPointer = head;
  // 포인터로 헤드를 가르키게 하고
  while (currentPointer.next !== null) {
    // 포인터의 다음이 null이 아닐 때까지, 뒤에 노드가 있는 경우
    currentPointer = currentPointer.next;
    // 포인터는 현재 포인터의 다음을 가르키게 하고
  }
  currentPointer.next = newNode;
  // 포인터의 다음이 Null이면 떠다니는 새로운 노드와 연결
}

for (let i = 3; i < 6; i++) {
  add(i * 10);
}

function print() {
  let currentPointer = head;
  while (currentPointer !== null) {
    // 내 자신이 null이 아닐 때까지, pointer.next !==null로 할 경우, 마지막 노드의 값이
    // 콘솔에 안찍히게 됨
    console.log(currentPointer.data);
    //while문 돌면서 데이터를 찍고
    currentPointer = currentPointer.next;
    // 포인터를 다음노드를 가르키게 하기
  }
}

function insert(findValue, insertedValue) {
  // 새 노드를 형성 후, 얘가 가르켜야 할 다음에를 포인터로 먼저 연결하고
  // 원래 연결을 끊어 새 노드에 붙이기
  const newNode = new Node(insertedValue);
  // 새로운 노드를 먼저 만들기
  let currentPointer = head;
  // 포인터로 헤드를 가르키고
  while (currentPointer.data !== findValue) {
    // 탈출문이 포인터의 데이터가 원하는 value를 만나기이기 때문에, 아니다를 while 조건 문에 넣고
    currentPointer = currentPointer.next;
    // 포인터는 다음 노드를 가르키게 하기
  }
  newNode.next = currentPointer.next;
  // 새로운 노드(35)를 현재 포인터의 다음 포인터(40)와 먼저 연결
  currentPointer.next = newNode;
  // 원래는 30이 40을 가리키고 있는데, 현재 포인터 findValue와 같은 데이터를 가진 애를 새로운 노드와 연결
}

// 만약 현재 포인터가 새로운 노드를 먼저 가르키게 한다면, 원래 가르키던 노드의 연결선이 잘라지기 떄문에
// 먼저 새로운 노드를 만들어서 포인터의 다음애와 연결을 시켜줌

// deleteNode 방법 1
function deleteNode(value){
  let currentPointer = head;
  let previousPointer = null;
  // pp를 먼저 null을 할당해서 cp를 따라가게 하기

  if(currentPointer.data === value){
    head = head.next;
  }else{
    while(currentPointer.data !== value){
      // 포인터의 데이터가 내가 지우려고 하는 값을 만나기 전까지
      previousPointer = currentPointer;
      // pp를 cp가 가르키고 있는 것을 먼저 가르키게 하고
      currentPointer =  currentPointer.next;
      // cp를 다음 노드를 가르키게 하기
    }
    previousPointer.next = currentPointer.next;
    // 지워야할 값을 만날 때, pp를 cp의 다음 값과 연결해주기
  }
}
// 함수가 종료되면 pointer는 지역 함수이기 때문에 지우려고 하는 값을 참조하는 것이 아무것도
// 없기 때문에 garbage collector가 그 값을 지워버림

// deleteNode 방법 2
function deleteNode(value) {
  let currentPointer = head;
  // cp를 헤드로 지정해주고
  if (currentPointer.data === value) {
    head = head.next;
  } else {
    while (currentPointer.next.data !== value) {
      currentPointer = currentPointer.next;
    }
    let temp = currentPointer.next;
    // 템프를 포인터의 다음 노드로 지정
    currentPointer.next = temp.next;
    // 포인터의 다음값을 템프의 다음값으로 지정해주면 자동으로 참조값이 없어진 Temp는 사라짐
  }
}

// 맨 앞의 값을 지우는 방법은 특별하게 처리해줘야 됨

insert(10, 15);
insert(30, 35);
insert(35, 37);

deleteNode(10);
deleteNode(50);
deleteNode(30);
print();
```