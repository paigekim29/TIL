# Cookie
* 어떤웹사이트에 들어갔을 때, 서버가 일방적으로 클라이언트에 전달하는 작은 데이터
* 서버가 웹브라우저에 정보를 저장하고불러올 수 있는 수단
* 단순히 서버에서 클라이언트에 쿠키를 전송하는 것만 의미하지 않고 클라이언트에서 서버로 쿠키를 전송하는 것도 포함
* 해당 도메인에 대해 쿠키가 존재하면, 웹브라우저는 도메인에게 http요청시 쿠키를 함께 전달
* 삭제하지 않으면, 사라지지 않는다라는 특징이 있어서, 사용자선호, 테마등 장시간 보존해야하는 정보 저장에 적합(장바구니, 로그인/아웃)
* 서버가 응답헤더에 set-cookie라는 property에 쿠키 이름과, 값등을 저장해서 보내고, 쿠키가 담긴 응답을 받은 클라이언트는 확인하고, 다음 요청 시, 자동으로 쿠키가 전송
* 옵션들을 지정한 다음 서버에서 클라이언트로 쿠키를 처음 전송하게 된다면 헤더에 Set-Cookie라는 프로퍼티에 쿠키를 담아 쿠키를 전송
* 이후 클라이언트 혹은 서버에서 쿠키를 전송해야 한다면 클라이언트는 헤더에 Cookie라는 프로퍼티에 쿠키를 담아 서버에 쿠키를 전송하게 됩니다.

## 서버가 클라이언트에 데이터를 저장 가능하고, 특정 조건을 만족하는 경우 가져올 수 있는데, 이 때 Cookie Options을 사용

### Domain
* 서버와 요청의 도메인이 일치하는 경우 쿠키 전송
* 도메인은 포트 및 서브 도메인 정보, 세부 경로를 포함하지 않는다
```
서브 도메인이란 www 같은 도메인 앞에 추가로 작성되는 부분
따라서 요청해야 할 URL이 http://www.localhost.com:3000/users/login 이라 하면 여기에서 Domain은 localhost.com
```

### Path
* 서버와 요청의 세부 경로가 일치하는 경우 쿠키 전송
* 세부 경로는 서버가 라우팅할 때 사용하는 경로
```
만약 요청해야 하는 URL이 "http://www.localhost.com:3000/users/login" 인 경우라면 여기에서 Path, 세부 경로는 "/users/login"
명시하지 않으면 기본으로 "/" 으로 설정
Path 옵션의 특징은 설정된 path를 전부 만족하는 경우 요청하는 Path가 추가로 더 존재하더라도 쿠키를 서버에 전송 가능하다. 즉 Path가 "/users"로 설정되어 있고, 요청하는 세부 경로가 "/users/login" 인 경우라면 쿠키 전송이 가능
하지만 "/user/login"으로 전송되는 요청은 Path 옵션을 만족하지 못하기 때문에 서버로 쿠키를 전송 불가
```

### MaxAge or Expires
* 쿠키의 유효기간 설정
* MaxAge는 앞으로 몇 초 동안 쿠키가 유효한지 설정하는 옵션
* Expires 은 MaxAge와 비슷하지만, 다만 언제까지 유효한지 Date를 지정하고, 이때 클라이언트의 시간을 기준으로 하여, 이후 지정된 시간, 날짜를 초과하게 되면 쿠키는 자동으로 파괴됩니다.
* 하지만 두 옵션이 모두 지정되지 않는 경우에는 브라우저의 탭을 닫아야만 쿠키가 제거될 수 있다

### HttpOnly
* 스크립트 쿠키 접근 가능 여부 결정 => 쿠키는 <script> 태그로 접근 가능하기에 XSS 공격에 취약해서, 민감한 정보나 개인정보는 담지 않는 것이 좋음
* 자바스크립트에서 브라우저의 쿠키에 접근 여부를 결정하는데, 만약 해당 옵션이 true로 설정된 경우, 자바스크립트에서는 쿠키에 접근이 불가
* 명시되지 않는 경우 기본으로 false로 지정되어 있는데, 만약 이 옵션이 false인 경우 자바스크립트에서 쿠키에 접근이 가능하므로 'XSS' 공격에 취약

### Secure
* HTTPS 프로토콜에서만 쿠키 전송 여부 결정
* 만약, 해당 옵션이 true로 설정된 경우, 'HTTPS' 프로토콜을 이용하여 통신하는 경우에만 쿠키를 전송 가능

### SameSite
* CORS 요청의 경우 옵션 및 메서드에 따라 쿠키 전송 여부 결정 => CSRF 공격을 막아줄 수 있음

#### 옵션에 따른 서버의 쿠키 전송 여부
* Lax: GET 메서드 요청만 쿠키 전송 가능
* Strict: 쿠키 전송을 할 수 없다/ Cross-Origin이 아닌 same-site 인 경우에만 쿠키를 전송 할 수 있습니다.
* None: 모든 메서드 요청에 쿠키 전송 가능
```
sameSite='none' 옵션은 Secure 쿠키 옵션 필요
'same-site'는 요청을 보낸 Origin과 서버의 도메인이 같은 경우
```

## 쿠키 기반 인증 (Cookie-based Authentication)
* 쿠키의 특성을 이용하여 서버는 클라이언트에 인증정보를 담은 쿠키를 전송하고, 클라이언트는 전달받은 쿠키를 요청과 같이 전송하여 Stateless 한 인터넷 연결을 Stateful 하게 유지가 가능하다.
* 하지만 기본적으로는 쿠키는 오랜 시간 동안 유지될 수 있고, 자바스크립트를 이용해서 쿠키에 접근할 수 있기 때문에 인증정보가 유출되기에 십상
* 이런 인증정보를 탈취하여 서버에 요청을 보낸다면 서버는 누가 요청을 보낸 건지 상관하지 않고 인증된 유저의 요청으로 취급하기 때문에, 개인 유저 정보 같은 민감한 정보에 접근이 가능
* 따라서 오랫동안 클라이언트에 저장이 가능하다는 특징은 장점이자 단점이 되어서 쿠키에 인증 정보를 담아 보관하는 쿠키 기반 인증 방식은 많이 사용되지 않는 방법
* 다만 인증정보 대신에 쇼핑몰의 카트에 담긴 내용 같은 민감하지 않은 정보나 여러 옵션을 장기 보관하는 용도로 현재까지도 쿠키는 유용하게 사용

### web application sercurity
* 개발자들이 웹사이트,모바일 어플, 웹 api등을 만들 때에 해커들의 공격을 막기 위해서 보안이 필수
* SQL Injection
* XSS
* CSRF

### CSRF(cross site request forgery)
* 다른 오리진(cross-site)에서 유저가 보내는 요청(request)을 조작(forgery)하는것
* ex. 이메일에 첨부된 링크를 누르면 내 은행 계좌의 돈이 빠져나감
* 해커가 직접 데이터를 접근할 수 없다
* ex. 다른 오리진이기 때문에, response에 직접 접근할 수 없음

#### 조건
1. 쿠키를 사용한 로그인
* 유저가 로그인 했을 때, 쿠키로 어떤 유저인 지 알 수 있어야 함
2. 예측할 수 있는 요청/parameter를 가지고 있어야 함
   * request에 해커가 모를 수 있는 정보가 담겨있으면 안됨
    
#### 막는 방법
1. CSRF 토큰 사용
* 서버측에서 CSRF 공격에 보호하기 위한 문자열을 유저의 브라우저와 웹 앱에만 제공
2. same-site cookie 사용하기
* 같은 도메인에서만 세션/쿠키 사용